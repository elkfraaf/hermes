( graph test1 ( ( node N_2 entailment ) ( node N_1 entailment ) ( node N_4 done ) ( node N_3 and ) ) ( ( edge E_6 __ ( N_2 base ) :type smt25 :encoding plain :content ( ( declare-sort |test.S1_Impl| 0 ) ( declare-sort |hermes.iml.aadl.Connection.T| 0 ) ( declare-sort |hermes.iml.aadl.Connection<Float>| 0 ) ( declare-sort |test.S1| 0 ) ( declare-sort |test.S2| 0 ) ( declare-fun |test.S1_Impl.base_0| ( |test.S1_Impl| ) |test.S1| ) ( declare-fun |test.S1_Impl.S2_sub| (   |test.S1_Impl|  ) |test.S2| ) ( declare-fun |test.S1_Impl.i1_TO_A| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.S1_Impl.i2_TO_A| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.S1_Impl.S2_TO_o1| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.inst| ( ) |test.S1_Impl| ) ( declare-fun |hermes.iml.aadl.Connection<Float>.source| (   |hermes.iml.aadl.Connection<Float>|  ) Real ) ( declare-fun |hermes.iml.aadl.Connection<Float>.target| (   |hermes.iml.aadl.Connection<Float>|  ) Real ) ( declare-fun |test.S1.i1| (   |test.S1|  ) Real ) ( declare-fun |test.S1.i2| (   |test.S1|  ) Real ) ( declare-fun |test.S1.o1| (   |test.S1|  ) Real ) ( declare-fun |test.S1.n| (   |test.S1|  ) Int ) ( declare-fun |test.S2.i1| (   |test.S2|  ) Real ) ( declare-fun |test.S2.i2| (   |test.S2|  ) Real ) ( declare-fun |test.S2.o1| (   |test.S2|  ) Real ) ( declare-fun |test.S2.alpha| (   |test.S2|  ) Real ) ( define-fun |test.S1_Impl.i1_TO_A.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.i1_TO_A| x!1 ) ) ( |test.S1.i1| ( |test.S1_Impl.base_0| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.i1_TO_A| x!1 ) ) ( |test.S2.i1| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ) ) ( define-fun |test.S1_Impl.i2_TO_A.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.i2_TO_A| x!1 ) ) ( |test.S1.i2| ( |test.S1_Impl.base_0| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.i2_TO_A| x!1 ) ) ( |test.S2.i2| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ) ) ( define-fun |test.S1_Impl.S2_TO_o1.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.S2_TO_o1| x!1 ) ) ( |test.S2.o1| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.S2_TO_o1| x!1 ) ) ( |test.S1.o1| ( |test.S1_Impl.base_0| x!1 ) ) ) ) ) ( define-fun |hermes.iml.aadl.Connection<Float>.a1| ( ( x!1 |hermes.iml.aadl.Connection<Float>| ) ) |Bool| ( = ( |hermes.iml.aadl.Connection<Float>.source| x!1 ) ( |hermes.iml.aadl.Connection<Float>.target| x!1 ) ) ) ( define-fun |test.S1.a1| ( ( x!1 |test.S1| ) ) |Bool| ( and ( >= ( |test.S1.n| x!1 ) 1 ) ( exists ( ( x Int ) ( y Int ) ) ( and ( and ( and ( and ( >= |y| 0 ) ( <= |y| ( |test.S1.n| x!1 ) ) ) ( >= |x| 1 ) ) ( <= |x| ( |test.S1.n| x!1 ) ) ) ( and ( or ( = ( |test.S1.i1| x!1 ) ( / ( to_real |x| ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ( = ( |test.S1.i1| x!1 ) ( / ( to_real ( * ( - 1 ) |x| ) ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ) ( or ( = ( |test.S1.i2| x!1 ) ( / ( to_real |y| ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ( = ( |test.S1.i2| x!1 ) ( / ( to_real ( * ( - 1 ) |y| ) ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ) ) ) ) ) ) ( define-fun |test.S1.g1| ( ( x!1 |test.S1| ) ) |Bool| ( and ( <= ( |test.S1.o1| x!1 ) 1 ) ( >= ( |test.S1.o1| x!1 ) ( - 1 ) ) ) ) ( define-fun |test.S2.a1| ( ( x!1 |test.S2| ) ) |Bool| ( and ( or ( = ( |test.S2.i1| x!1 ) 1 ) ( = ( |test.S2.i1| x!1 ) ( - 1 ) ) ) ( or ( or ( = ( |test.S2.i2| x!1 ) 0 ) ( = ( |test.S2.i2| x!1 ) 1 ) ) ( = ( |test.S2.i2| x!1 ) ( - 1 ) ) ) ) ) ( define-fun |test.S2.g1| ( ( x!1 |test.S2| ) ) |Bool| ( = ( |test.S2.o1| x!1 ) ( + ( * ( * ( |test.S2.i1| x!1 ) ( pow 2.0 0.5 ) ) ( |sin| ( |test.S2.alpha| x!1 ) ) ) ( * ( * ( |test.S2.i2| x!1 ) ( pow 2.0 0.5 ) ) ( |cos| ( |test.S2.alpha| x!1 ) ) ) ) ) ) ( assert ( = ( |test.S1_Impl.i1_TO_A.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.i1_TO_A| |test.inst| ) ) true ) ) ( assert ( = ( |test.S1_Impl.i2_TO_A.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.i2_TO_A| |test.inst| ) ) true ) ) ( assert ( = ( |test.S1_Impl.S2_TO_o1.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.S2_TO_o1| |test.inst| ) ) true ) ) ) ) ( edge E_7 __ ( N_2 kb ) :type smt25 :encoding plain :content ((and (= ( |test.S1.n|  ( |test.S1_Impl.base_0| |test.inst| )) 1) (distinct (|test.S1_Impl.i1_TO_A| |test.inst|) (|test.S1_Impl.i2_TO_A| |test.inst|) (|test.S1_Impl.S2_TO_o1| |test.inst|)) ( |test.S1.a1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) )) ( edge E_8 __ ( N_2 g ) :type smt25 :encoding plain :content ( ( |test.S2.a1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( edge E_9 ( N_2 valid ) ( N_3 in ) :type boolX :encoding plain :content __ ) ( edge E_10 ( N_2 cmodel ) __ :type evaluate :encoding plain :content ( ( get-value ( ( |test.S1.i1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.i2|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.o1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.n|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S2.i1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.i2| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.o1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.alpha| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ) ) ( edge E_1 __ ( N_1 base ) :type smt25 :encoding plain :content ( ( declare-sort |test.S1_Impl| 0 ) ( declare-sort |hermes.iml.aadl.Connection.T| 0 ) ( declare-sort |hermes.iml.aadl.Connection<Float>| 0 ) ( declare-sort |test.S1| 0 ) ( declare-sort |test.S2| 0 ) ( declare-fun |test.S1_Impl.base_0| ( |test.S1_Impl| ) |test.S1| ) ( declare-fun |test.S1_Impl.S2_sub| (   |test.S1_Impl|  ) |test.S2| ) ( declare-fun |test.S1_Impl.i1_TO_A| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.S1_Impl.i2_TO_A| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.S1_Impl.S2_TO_o1| (   |test.S1_Impl|  ) |hermes.iml.aadl.Connection<Float>| ) ( declare-fun |test.inst| ( ) |test.S1_Impl| ) ( declare-fun |hermes.iml.aadl.Connection<Float>.source| (   |hermes.iml.aadl.Connection<Float>|  ) Real ) ( declare-fun |hermes.iml.aadl.Connection<Float>.target| (   |hermes.iml.aadl.Connection<Float>|  ) Real ) ( declare-fun |test.S1.i1| (   |test.S1|  ) Real ) ( declare-fun |test.S1.i2| (   |test.S1|  ) Real ) ( declare-fun |test.S1.o1| (   |test.S1|  ) Real ) ( declare-fun |test.S1.n| (   |test.S1|  ) Int ) ( declare-fun |test.S2.i1| (   |test.S2|  ) Real ) ( declare-fun |test.S2.i2| (   |test.S2|  ) Real ) ( declare-fun |test.S2.o1| (   |test.S2|  ) Real ) ( declare-fun |test.S2.alpha| (   |test.S2|  ) Real ) ( define-fun |test.S1_Impl.i1_TO_A.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.i1_TO_A| x!1 ) ) ( |test.S1.i1| ( |test.S1_Impl.base_0| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.i1_TO_A| x!1 ) ) ( |test.S2.i1| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ) ) ( define-fun |test.S1_Impl.i2_TO_A.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.i2_TO_A| x!1 ) ) ( |test.S1.i2| ( |test.S1_Impl.base_0| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.i2_TO_A| x!1 ) ) ( |test.S2.i2| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ) ) ( define-fun |test.S1_Impl.S2_TO_o1.init| ( ( x!1 |test.S1_Impl| ) ) Bool ( and ( = ( |hermes.iml.aadl.Connection<Float>.source| ( |test.S1_Impl.S2_TO_o1| x!1 ) ) ( |test.S2.o1| ( |test.S1_Impl.S2_sub| x!1 ) ) ) ( = ( |hermes.iml.aadl.Connection<Float>.target| ( |test.S1_Impl.S2_TO_o1| x!1 ) ) ( |test.S1.o1| ( |test.S1_Impl.base_0| x!1 ) ) ) ) ) ( define-fun |hermes.iml.aadl.Connection<Float>.a1| ( ( x!1 |hermes.iml.aadl.Connection<Float>| ) ) |Bool| ( = ( |hermes.iml.aadl.Connection<Float>.source| x!1 ) ( |hermes.iml.aadl.Connection<Float>.target| x!1 ) ) ) ( define-fun |test.S1.a1| ( ( x!1 |test.S1| ) ) |Bool| ( and ( >= ( |test.S1.n| x!1 ) 1 ) ( exists ( ( x Int ) ( y Int ) ) ( and ( and ( and ( and ( >= |y| 0 ) ( <= |y| ( |test.S1.n| x!1 ) ) ) ( >= |x| 1 ) ) ( <= |x| ( |test.S1.n| x!1 ) ) ) ( and ( or ( = ( |test.S1.i1| x!1 ) ( / ( to_real |x| ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ( = ( |test.S1.i1| x!1 ) ( / ( to_real ( * ( - 1 ) |x| ) ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ) ( or ( = ( |test.S1.i2| x!1 ) ( / ( to_real |y| ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ( = ( |test.S1.i2| x!1 ) ( / ( to_real ( * ( - 1 ) |y| ) ) ( to_real ( |test.S1.n| x!1 ) ) ) ) ) ) ) ) ) ) ( define-fun |test.S1.g1| ( ( x!1 |test.S1| ) ) |Bool| ( and ( <= ( |test.S1.o1| x!1 ) 1 ) ( >= ( |test.S1.o1| x!1 ) ( - 1 ) ) ) ) ( define-fun |test.S2.a1| ( ( x!1 |test.S2| ) ) |Bool| ( and ( or ( = ( |test.S2.i1| x!1 ) 1 ) ( = ( |test.S2.i1| x!1 ) ( - 1 ) ) ) ( or ( or ( = ( |test.S2.i2| x!1 ) 0 ) ( = ( |test.S2.i2| x!1 ) 1 ) ) ( = ( |test.S2.i2| x!1 ) ( - 1 ) ) ) ) ) ( define-fun |test.S2.g1| ( ( x!1 |test.S2| ) ) |Bool| ( = ( |test.S2.o1| x!1 ) ( + ( * ( * ( |test.S2.i1| x!1 ) ( pow 2.0 0.5 ) ) ( |sin| ( |test.S2.alpha| x!1 ) ) ) ( * ( * ( |test.S2.i2| x!1 ) ( pow 2.0 0.5 ) ) ( |cos| ( |test.S2.alpha| x!1 ) ) ) ) ) ) ( assert ( = ( |test.S1_Impl.i1_TO_A.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.i1_TO_A| |test.inst| ) ) true ) ) ( assert ( = ( |test.S1_Impl.i2_TO_A.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.i2_TO_A| |test.inst| ) ) true ) ) ( assert ( = ( |test.S1_Impl.S2_TO_o1.init| |test.inst| ) true ) ) ( assert ( = ( |hermes.iml.aadl.Connection<Float>.a1| ( |test.S1_Impl.S2_TO_o1| |test.inst| ) ) true ) ) ) ) ( edge E_2 __ ( N_1 kb ) :type smt25 :encoding plain :content ( ( and ( |test.S1.a1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ( => ( |test.S2.a1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ( |test.S2.g1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ) ) ( edge E_3 __ ( N_1 g ) :type smt25 :encoding plain :content ( ( |test.S1.g1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( edge E_4 ( N_1 valid ) ( N_3 in ) :type boolX :encoding plain :content __ ) ( edge E_5 ( N_1 cmodel ) __ :type evaluate :encoding plain :content ( ( get-value ( ( |test.S1.i1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.i2|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.o1|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S1.n|  ( |test.S1_Impl.base_0| |test.inst| )  ) ) ) ( get-value ( ( |test.S2.i1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.i2| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.o1| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ( get-value ( ( |test.S2.alpha| ( |test.S1_Impl.S2_sub| |test.inst| ) ) ) ) ) ) ( edge E_11 ( N_3 out ) ( N_4 in ) :type boolX :encoding plain :content __ ) ) )
