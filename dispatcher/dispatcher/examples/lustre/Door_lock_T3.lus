--===============================================
--
--                 The Door Lock
--
--===============================================

node HasHappened(X : bool) returns (Y : bool);
let
  Y = X or (false -> pre Y);
tel

node Since( X, Y : bool )
returns ( SinceXY : bool );
let
  SinceXY = X or (Y and (false -> pre SinceXY));
tel

-----------------------------------------------

-----------
-- KeyPad
-----------

-- Specification
contract KeypadSpec( Digit: int; Press: bool ) returns ( Request: bool; Code: int );
let
  var PreRequest: bool = false -> pre Request;

  assume "A1: Digit is always non-negative"
    0 <= Digit;

  assume "A2: Digit is always smaller than nine"
    Digit <= 9;

  guarantee "R0: Whenever there is a request the output code is in the range [0..999]"
    Request => (0 <= Code and Code <= 999);

  guarantee "R1: The component will not send an unlock requests before its third cycle"
    (not Request) -> (not PreRequest) -> true;
 
  guarantee "R2: Any two distinct unlock requests are separated by at least 2 clock cycles"
    true -> Request => not PreRequest and not pre PreRequest;

  guarantee "R3: Code is always non-negative"
    Code >= 0;

  guarantee "R4: Whenever there is a request a digit is pressed"
  Request => Press;

tel

-- Implementation
node Keypad( Digit: int; Press: bool ) returns ( Request: bool; Code: int );
(*@contract import KeypadSpec(Digit, Press) returns (Request, Code); *)
var PressedDigits, ElapsedTime, ExpirationTime: int;
    IncompleteCode: bool;
let
  ExpirationTime = 9;

  IncompleteCode = false -> 0 < pre PressedDigits and pre PressedDigits < 3;

  ElapsedTime = 0 -> 
                if Press then 0 
                else if pre ElapsedTime < ExpirationTime and
                        IncompleteCode then pre ElapsedTime + 1
                else 0;

  PressedDigits = (if Press then 1 else 0) ->
                  if ElapsedTime = ExpirationTime then 0
                  else if not Press then pre PressedDigits 
                  else if pre PressedDigits = 3 then 1 
                  else pre PressedDigits + 1;

  Request = false -> Press and PressedDigits = 3;

  Code = if Press then 
           (Digit -> if PressedDigits = 1 then Digit else 10 * (pre Code) + Digit)
         else 
           (0 -> pre Code); -- 0 arbitrary value
tel

------------
-- Control 
------------

-- Specification
contract ControlSpec( Request : bool; Code : int; MasterKey : bool )
returns ( CurrentCode : int; Granted : bool );
let
  -- R1 does not hold without the assumption that Code is always non-negative
  assume "A1: Code is always non-negative"
    0 <= Code;

  guarantee "R1: Until the access code is first set, the door cannot be unlocked"
    not HasHappened(Request and MasterKey) => not Granted;

  -- R2: Unless the current code is being changed, an unlock request is granted 
  -- whenever the provided code equals the current access code.
  guarantee "R2: unlock request is granted whenever the provided code equals the current one"
    (Request and (Code = CurrentCode) and not MasterKey) => Granted;

  guarantee "R3: An unlock request is granted only if the provided code equals the current access code"
    Granted => Code = CurrentCode;

  -- R4: Once it has been set, the current code can change only when the master key is inserted.
  guarantee "R4: Once it has been set, the current code can change only when the master key is inserted"
    true -> (HasHappened(MasterKey and Request) and CurrentCode <> pre CurrentCode  => MasterKey);

  guarantee "R5: Unlocking granted only if there is a request and the master key is not inserted"
    Granted => Request and not MasterKey;

tel

-- Implementation
node Control( Request : bool; Code : int; MasterKey : bool )
returns ( CurrentCode : int; Granted : bool );
(*@contract import ControlSpec(Request, Code, MasterKey)
                   returns (CurrentCode, Granted); *)
let
  CurrentCode  = -1 -> if MasterKey and Request then Code 
                       else pre CurrentCode;

  Granted =  Request and (Code = CurrentCode) and not MasterKey;
tel

---------------------------------------------------------------------
-- Lock node
---------------------------------------------------------------------

-- Specification
contract LockSpec( Digit: int; Press: bool; MasterKey: bool )
returns ( Unlocking : bool );
let
  -- C counts the number of cycles Unlocking has be continuously true so far 
  var C: int = if Unlocking then (1 -> pre C + 1) else 0;

  var Locks: bool = false -> pre Unlocking and not Unlocking;

  assume "A1: Digit is always non-negative"
    0 <= Digit;

  guarantee "R1: The door will never be held open for more than 4 clock cycles at a time"
   (C <= 4);
 
  -- R2: Once a door locks (after being unlocked) it remains locked 
  -- as long as no one uses the keypad
  guarantee "R2: Door locks remains locked as long as no one uses the keypad"
    Since(Locks, not Press) => not Unlocking;
 
tel

-- Implementation
node Lock( Digit: int; Press: bool; MasterKey: bool )
returns ( Unlocking : bool );
(*@contract import LockSpec(Digit, Press, MasterKey) returns (Unlocking); *)
var CurrentCode, Code, Timer: int; 
    Request, Granted: bool;
    SafeDigit: int;
let

  SafeDigit = if Digit > 9 then 9 else Digit;

  (Request, Code) = Keypad(SafeDigit, Press);

  (CurrentCode, Granted) = Control(Request, Code, MasterKey);

  Timer = 0 -> if pre Unlocking then pre Timer - 1
               else if Granted then 4 
               else 0;

  Unlocking = Timer > 0;
tel

